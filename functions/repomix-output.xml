This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  config/
    constants.ts
  handlers/
    analyzeFoodImage.ts
    backup.ts
    credits.ts
    quickScan.ts
    registerDevice.ts
    sendDailyNudge.ts
  middleware/
    auth.ts
    latency.ts
  services/
    backup.ts
    fcm.ts
    firestore.ts
    user.ts
    vision.ts
  types/
    index.ts
    visionSchemas.ts
  utils/
    errors.ts
    validation.ts
  api.ts
  index.ts
.eslintrc.js
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/config/constants.ts">
// Configuration constants

export const COLLECTIONS = {
  DEVICES: "devices",
  NUDGES: "nudges",
  FOOD_ANALYSES: "food_analyses",
} as const;

export const LIMITS = {
  MAX_IMAGE_SIZE_BYTES: 5 * 1024 * 1024, // 5MB
  DEVICE_ACTIVE_DAYS: 30, // Consider device active if seen within this many days
  FCM_BATCH_SIZE: 500, // Max devices per FCM batch
} as const;

export const NUDGE_CONFIG = {
  DEFAULT_TITLE: "Time to log your weight! ‚öñÔ∏è",
  DEFAULT_BODY: "Consistency is key! Take a moment to log your weight today.",
} as const;

export const NUDGE_TYPES = {
  WEIGHT_REMINDER: {
    title: "Good morning! ‚öñÔ∏è",
    body: "Time to log your weight",
    link: "platewise://entry",
  },
  BREAKFAST: {
    title: "Breakfast time! üç≥",
    body: "Had breakfast? Snap a quick photo",
    link: "platewise://food/capture",
  },
  LUNCH: {
    title: "Lunch time! ü•ó",
    body: "Capture what you're eating",
    link: "platewise://food/capture",
  },
  SNACKS: {
    title: "Snack check üçé",
    body: "Snacking? Log it to stay on track",
    link: "platewise://food/capture",
  },
  DINNER: {
    title: "Dinner time! üçΩÔ∏è",
    body: "Don't forget to log your meal",
    link: "platewise://food/capture",
  },
  EVENING_CHECKIN: {
    title: "Daily check-in üìä",
    body: "How was your day? Check your progress",
    link: "platewise://dashboard",
  },
} as const;

export const VISION_CONFIG = {
  MODEL: "gpt-4o",
  TEXT_MODEL: "gpt-4o", // Text-only model for Stage 2 (no vision capability needed)
  PERCEPTION_MAX_TOKENS: 384, // Stage 1: tight limit for perception-only
  NUTRITION_MAX_TOKENS: 512, // Stage 2: text-only nutrition estimation
  MAX_TOKENS: 2048, // Legacy: single-pass mode
  TIMEOUT_MS: 60000,
  SUPPORTED_FORMATS: ["image/jpeg", "image/png", "image/webp"],
  PROMPT_VERSION: "vision_v4_2stage",
  MIN_CONFIDENCE: 0.6, // Gate Stage 2 if perception confidence is below this
} as const;

export const FUNCTION_CONFIG = {
  REGION: "us-central1",
  TIMEOUT_SECONDS: 60,
  MEMORY: "256MiB" as const,
  ANALYSIS_MEMORY: "512MiB" as const,
} as const;

export const BACKUP_CONFIG = {
  STORAGE_BUCKET: process.env.STORAGE_BUCKET || "",
  STORAGE_PATH_PREFIX: "users",
  BACKUP_FILENAME: "current.gz",
} as const;
</file>

<file path="src/handlers/analyzeFoodImage.ts">
import { Request, Response } from "express";
import { logger } from "firebase-functions/v2";
import Busboy from "busboy";
import { analyzeFood } from "../services/vision";
import { deductCredit } from "../services/user";
import { foodAnalysisSchema, validateInput } from "../utils/validation";
import { handleError, errors } from "../utils/errors";
import { LIMITS, VISION_CONFIG } from "../config/constants";
import { AuthenticatedRequest, verifyAuth } from "../middleware/auth";

// Extend Express Request to include rawBody (added by Firebase Functions)
interface FirebaseRequest extends Request {
  rawBody?: Buffer;
}

interface ParsedRequest {
  imageBase64: string;
  mimeType: string;
}

function parseMultipartRequest(req: FirebaseRequest): Promise<ParsedRequest> {
  return new Promise((resolve, reject) => {
    // eslint-disable-next-line new-cap
    const bb = Busboy({
      headers: req.headers,
      limits: {
        fileSize: LIMITS.MAX_IMAGE_SIZE_BYTES,
        files: 1,
      },
    });

    let imageBuffer: Buffer | null = null;
    let mimeType = "";
    let fileLimitExceeded = false;

    bb.on("file", (
      _fieldname: string,
      file: NodeJS.ReadableStream,
      info: { filename: string; encoding: string; mimeType: string },
    ) => {
      mimeType = info.mimeType;
      const chunks: Buffer[] = [];

      file.on("data", (chunk: Buffer) => {
        chunks.push(chunk);
      });

      file.on("limit", () => {
        fileLimitExceeded = true;
      });

      file.on("end", () => {
        imageBuffer = Buffer.concat(chunks);
      });
    });

    bb.on("finish", () => {
      if (fileLimitExceeded) {
        reject(errors.imageTooLarge(LIMITS.MAX_IMAGE_SIZE_BYTES));
        return;
      }

      if (!imageBuffer) {
        reject(errors.invalidRequest("No image provided"));
        return;
      }

      resolve({
        imageBase64: imageBuffer.toString("base64"),
        mimeType,
      });
    });

    bb.on("error", (error: Error) => {
      reject(error);
    });

    // Handle the case where body is already parsed (e.g., by Firebase Functions)
    if (req.rawBody) {
      bb.end(req.rawBody);
    } else {
      req.pipe(bb);
    }
  });
}

function parseJsonRequest(req: Request): ParsedRequest {
  const validation = validateInput(foodAnalysisSchema, req.body);
  if (!validation.success) {
    throw errors.invalidRequest(validation.error);
  }

  const { image } = validation.data;

  if (!image) {
    throw errors.invalidRequest("image is required");
  }

  return {
    imageBase64: image,
    mimeType: "image/jpeg", // Assume JPEG for base64
  };
}

// Create a mutable copy of supported formats for includes check
const supportedFormats: string[] = [...VISION_CONFIG.SUPPORTED_FORMATS];

/**
 * Food Image Analysis Handler
 * Requires authentication and deducts 1 credit per analysis
 */
export async function analyzeFoodImage(
  req: FirebaseRequest & AuthenticatedRequest,
  res: Response,
): Promise<void> {
  try {
    // Only allow POST
    if (req.method !== "POST") {
      res.status(405).json({
        success: false,
        error: "Method not allowed",
      });
      return;
    }

    // Verify authentication
    await new Promise<void>((resolve, reject) => {
      verifyAuth(req, res, (err?: unknown) => {
        if (err) reject(err);
        else resolve();
      });
    });

    // If verifyAuth responded with error, stop here
    if (res.headersSent) return;

    const uid = req.uid!; // Safe: verifyAuth ensures uid exists
    logger.info(`Analyzing food image for user: ${uid}`);

    // Deduct credit before analysis (throws if insufficient)
    const remainingCredits = await deductCredit(uid);
    logger.info(`Credit deducted, remaining: ${remainingCredits}`);

    let parsed: ParsedRequest;

    // Parse based on content type
    const contentType = req.headers["content-type"] || "";
    if (contentType.includes("multipart/form-data")) {
      parsed = await parseMultipartRequest(req);
    } else if (contentType.includes("application/json")) {
      parsed = parseJsonRequest(req);
    } else {
      throw errors.invalidRequest(
        "Content-Type must be multipart/form-data or application/json",
      );
    }

    // Validate image format
    if (!supportedFormats.includes(parsed.mimeType)) {
      throw errors.unsupportedFormat([...VISION_CONFIG.SUPPORTED_FORMATS]);
    }

    // Analyze the food image
    const nutrition = await analyzeFood(parsed.imageBase64);

    res.status(200).json({
      success: true,
      nutrition,
      creditsRemaining: remainingCredits,
    });
  } catch (error) {
    handleError(error, res);
  }
}
</file>

<file path="src/handlers/backup.ts">
import { Request, Response } from "express";
import { logger } from "firebase-functions/v2";
import { saveBackup, loadBackup, getBackupInfo } from "../services/backup";
import { backupSchema, validateInput } from "../utils/validation";
import { handleError, errors } from "../utils/errors";
import { AuthenticatedRequest, verifyAuth } from "../middleware/auth";

/**
 * POST /backup
 * Save user data backup
 */
export async function createBackup(
  req: Request & AuthenticatedRequest,
  res: Response,
): Promise<void> {
  try {
    if (req.method !== "POST") {
      res.status(405).json({ success: false, error: "Method not allowed" });
      return;
    }

    // Verify authentication
    await new Promise<void>((resolve, reject) => {
      verifyAuth(req, res, (err?: unknown) => {
        if (err) reject(err);
        else resolve();
      });
    });

    if (res.headersSent) return;

    const uid = req.uid!; // Safe: verifyAuth ensures uid exists
    logger.info(`Creating backup for user: ${uid}`);

    // Validate input
    const validation = validateInput(backupSchema, req.body);
    if (!validation.success) {
      throw errors.invalidRequest(validation.error);
    }

    await saveBackup(uid, validation.data);

    res.status(200).json({
      success: true,
      message: "Backup saved successfully",
    });
  } catch (error) {
    handleError(error, res);
  }
}

/**
 * POST /restore
 * Restore user data from backup
 */
export async function restoreBackup(
  req: Request & AuthenticatedRequest,
  res: Response,
): Promise<void> {
  try {
    if (req.method !== "POST") {
      res.status(405).json({ success: false, error: "Method not allowed" });
      return;
    }

    // Verify authentication
    await new Promise<void>((resolve, reject) => {
      verifyAuth(req, res, (err?: unknown) => {
        if (err) reject(err);
        else resolve();
      });
    });

    if (res.headersSent) return;

    const uid = req.uid!; // Safe: verifyAuth ensures uid exists
    logger.info(`Restoring backup for user: ${uid}`);

    const backup = await loadBackup(uid);

    res.status(200).json({
      success: true,
      data: backup,
    });
  } catch (error) {
    handleError(error, res);
  }
}

/**
 * GET /backup-status
 * Check if backup exists and get metadata
 */
export async function getBackupStatus(
  req: Request & AuthenticatedRequest,
  res: Response,
): Promise<void> {
  try {
    if (req.method !== "GET") {
      res.status(405).json({ success: false, error: "Method not allowed" });
      return;
    }

    // Verify authentication
    await new Promise<void>((resolve, reject) => {
      verifyAuth(req, res, (err?: unknown) => {
        if (err) reject(err);
        else resolve();
      });
    });

    if (res.headersSent) return;

    const uid = req.uid!; // Safe: verifyAuth ensures uid exists
    const info = await getBackupInfo(uid);

    res.status(200).json({
      success: true,
      ...info,
    });
  } catch (error) {
    handleError(error, res);
  }
}
</file>

<file path="src/handlers/credits.ts">
import { Request, Response } from "express";
import { logger } from "firebase-functions/v2";
import { getCredits, getOrCreateUser } from "../services/user";
import { handleError } from "../utils/errors";
import { AuthenticatedRequest, verifyAuth } from "../middleware/auth";

/**
 * GET /credits
 * Get current user's credit balance
 */
export async function getCreditsHandler(
  req: Request & AuthenticatedRequest,
  res: Response,
): Promise<void> {
  try {
    if (req.method !== "GET") {
      res.status(405).json({ success: false, error: "Method not allowed" });
      return;
    }

    // Verify authentication
    await new Promise<void>((resolve, reject) => {
      verifyAuth(req, res, (err?: unknown) => {
        if (err) reject(err);
        else resolve();
      });
    });

    if (res.headersSent) return;

    const uid = req.uid!; // Safe: verifyAuth ensures uid exists
    logger.info(`Getting credits for user: ${uid}`);

    const credits = await getCredits(uid);

    res.status(200).json({
      success: true,
      credits,
    });
  } catch (error) {
    handleError(error, res);
  }
}

/**
 * GET /user/me
 * Get current user profile including credits
 */
export async function getUserProfile(
  req: Request & AuthenticatedRequest,
  res: Response,
): Promise<void> {
  try {
    if (req.method !== "GET") {
      res.status(405).json({ success: false, error: "Method not allowed" });
      return;
    }

    // Verify authentication
    await new Promise<void>((resolve, reject) => {
      verifyAuth(req, res, (err?: unknown) => {
        if (err) reject(err);
        else resolve();
      });
    });

    if (res.headersSent) return;

    const uid = req.uid!; // Safe: verifyAuth ensures uid exists
    logger.info(`Getting profile for user: ${uid}`);

    const userData = await getOrCreateUser(uid);

    res.status(200).json({
      success: true,
      user: {
        uid,
        aiCredits: userData.aiCredits,
        totalGranted: userData.totalGranted,
        totalUsed: userData.totalUsed,
        createdAt: userData.createdAt.toDate().toISOString(),
        lastActiveAt: userData.lastActiveAt.toDate().toISOString(),
      },
    });
  } catch (error) {
    handleError(error, res);
  }
}
</file>

<file path="src/handlers/quickScan.ts">
import { Request, Response } from "express";
import { logger } from "firebase-functions/v2";
import Busboy from "busboy";
import { quickAnalyzeFood } from "../services/vision";
import { deductCredit } from "../services/user";
import { foodAnalysisSchema, validateInput } from "../utils/validation";
import { handleError, errors } from "../utils/errors";
import { LIMITS, VISION_CONFIG } from "../config/constants";
import { AuthenticatedRequest, verifyAuth } from "../middleware/auth";

// Extend Express Request to include rawBody (added by Firebase Functions)
interface FirebaseRequest extends Request {
    rawBody?: Buffer;
}

interface ParsedRequest {
    imageBase64: string;
    mimeType: string;
}

function parseMultipartRequest(req: FirebaseRequest): Promise<ParsedRequest> {
  return new Promise((resolve, reject) => {
    // eslint-disable-next-line new-cap
    const bb = Busboy({
      headers: req.headers,
      limits: {
        fileSize: LIMITS.MAX_IMAGE_SIZE_BYTES,
        files: 1,
      },
    });

    let imageBuffer: Buffer | null = null;
    let mimeType = "";
    let fileLimitExceeded = false;

    bb.on("file", (
      _fieldname: string,
      file: NodeJS.ReadableStream,
      info: { filename: string; encoding: string; mimeType: string },
    ) => {
      mimeType = info.mimeType;
      const chunks: Buffer[] = [];

      file.on("data", (chunk: Buffer) => {
        chunks.push(chunk);
      });

      file.on("limit", () => {
        fileLimitExceeded = true;
      });

      file.on("end", () => {
        imageBuffer = Buffer.concat(chunks);
      });
    });

    bb.on("finish", () => {
      if (fileLimitExceeded) {
        reject(errors.imageTooLarge(LIMITS.MAX_IMAGE_SIZE_BYTES));
        return;
      }

      if (!imageBuffer) {
        reject(errors.invalidRequest("No image provided"));
        return;
      }

      resolve({
        imageBase64: imageBuffer.toString("base64"),
        mimeType,
      });
    });

    bb.on("error", (error: Error) => {
      reject(error);
    });

    // Handle the case where body is already parsed (e.g., by Firebase Functions)
    if (req.rawBody) {
      bb.end(req.rawBody);
    } else {
      req.pipe(bb);
    }
  });
}

function parseJsonRequest(req: Request): ParsedRequest {
  const validation = validateInput(foodAnalysisSchema, req.body);
  if (!validation.success) {
    throw errors.invalidRequest(validation.error);
  }

  const { image } = validation.data;

  if (!image) {
    throw errors.invalidRequest("image is required");
  }

  return {
    imageBase64: image,
    mimeType: "image/jpeg", // Assume JPEG for base64
  };
}

// Create a mutable copy of supported formats for includes check
const supportedFormats: string[] = [...VISION_CONFIG.SUPPORTED_FORMATS];

/**
 * Quick Scan Handler
 * Lightweight food identification - returns food name, confidence, calories, one-liner
 * Requires authentication and deducts 1 credit per scan
 */
export async function quickScan(
  req: FirebaseRequest & AuthenticatedRequest,
  res: Response,
): Promise<void> {
  try {
    // Only allow POST
    if (req.method !== "POST") {
      res.status(405).json({
        success: false,
        error: "Method not allowed",
      });
      return;
    }

    // Verify authentication
    await new Promise<void>((resolve, reject) => {
      verifyAuth(req, res, (err?: unknown) => {
        if (err) reject(err);
        else resolve();
      });
    });

    // If verifyAuth responded with error, stop here
    if (res.headersSent) return;

    const uid = req.uid!; // Safe: verifyAuth ensures uid exists
    logger.info(`Quick scan for user: ${uid}`);

    // Deduct credit before analysis (throws if insufficient)
    const remainingCredits = await deductCredit(uid);
    logger.info(`Credit deducted, remaining: ${remainingCredits}`);

    let parsed: ParsedRequest;

    // Parse based on content type
    const contentType = req.headers["content-type"] || "";
    if (contentType.includes("multipart/form-data")) {
      parsed = await parseMultipartRequest(req);
    } else if (contentType.includes("application/json")) {
      parsed = parseJsonRequest(req);
    } else {
      throw errors.invalidRequest(
        "Content-Type must be multipart/form-data or application/json",
      );
    }

    // Validate image format
    if (!supportedFormats.includes(parsed.mimeType)) {
      throw errors.unsupportedFormat([...VISION_CONFIG.SUPPORTED_FORMATS]);
    }

    // Quick analyze the food image
    const result = await quickAnalyzeFood(parsed.imageBase64);

    res.status(200).json({
      success: true,
      ...result,
      creditsRemaining: remainingCredits,
    });
  } catch (error) {
    handleError(error, res);
  }
}
</file>

<file path="src/handlers/registerDevice.ts">
import { Request, Response } from "express";
import { logger } from "firebase-functions/v2";
import { upsertDevice } from "../services/firestore";
import { deviceRegistrationSchema, validateInput } from "../utils/validation";
import { handleError, errors } from "../utils/errors";

export async function registerDevice(req: Request, res: Response): Promise<void> {
  try {
    // Only allow POST
    if (req.method !== "POST") {
      res.status(405).json({
        success: false,
        error: "Method not allowed",
      });
      return;
    }

    // Validate input
    const validation = validateInput(deviceRegistrationSchema, req.body);
    if (!validation.success) {
      throw errors.invalidRequest(validation.error);
    }

    const { deviceId, fcmToken, platform } = validation.data;

    logger.info(`Registering device: ${deviceId}`, { platform });

    // Upsert device in Firestore
    await upsertDevice(deviceId, fcmToken, platform);

    res.status(200).json({
      success: true,
      message: "Device registered successfully",
    });
  } catch (error) {
    handleError(error, res);
  }
}
</file>

<file path="src/handlers/sendDailyNudge.ts">
import { logger } from "firebase-functions/v2";
import { getActiveDevices, logNudge } from "../services/firestore";
import { sendBatchNotifications } from "../services/fcm";
import { NUDGE_TYPES } from "../config/constants";

export type NudgeType = keyof typeof NUDGE_TYPES;

/**
 * Factory function that creates a nudge handler for a specific type.
 * Each nudge type has its own title, body, and deep link.
 */
export function createNudgeHandler(nudgeType: NudgeType) {
  return async function sendNudge(): Promise<void> {
    const config = NUDGE_TYPES[nudgeType];
    logger.info(`Starting ${nudgeType} nudge job`, { link: config.link });

    try {
      // Get all active devices
      const devices = await getActiveDevices();
      logger.info(`Found ${devices.length} active devices`);

      if (devices.length === 0) {
        logger.info("No active devices to notify");
        return;
      }

      // Send notifications with deep link
      const results = await sendBatchNotifications(
        devices,
        config.title,
        config.body,
        config.link,
      );

      // Log each nudge result
      const logPromises = results.map((result) =>
        logNudge({
          deviceId: result.deviceId,
          status: result.success ? "success" : "failed",
          title: config.title,
          body: config.body,
          error: result.error,
        }),
      );

      await Promise.all(logPromises);

      const successCount = results.filter((r) => r.success).length;
      logger.info(`${nudgeType} nudge complete: ${successCount}/${results.length} successful`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      logger.error(`${nudgeType} nudge failed: ${errorMessage}`);
      throw error;
    }
  };
}

// Legacy export for backward compatibility
export const sendDailyNudge = createNudgeHandler("WEIGHT_REMINDER");
</file>

<file path="src/middleware/auth.ts">
import { Request, Response, NextFunction } from "express";
import { getAuth } from "firebase-admin/auth";
import { logger } from "firebase-functions/v2";
import { errors } from "../utils/errors";

/**
 * Extended request with authenticated user info
 * uid is optional in type definition because it's added at runtime
 */
export interface AuthenticatedRequest extends Request {
  uid?: string;
  rawBody?: Buffer;
}

/**
 * Middleware to verify Firebase ID token
 * Extracts uid from the token and attaches it to the request
 */
export async function verifyAuth(
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    const error = errors.unauthorized("Missing or invalid Authorization header");
    res.status(error.statusCode).json({
      success: false,
      error: error.message,
      code: error.code,
    });
    return;
  }

  const idToken = authHeader.split("Bearer ")[1];

  try {
    const decodedToken = await getAuth().verifyIdToken(idToken);
    (req as AuthenticatedRequest).uid = decodedToken.uid;
    next();
  } catch (err) {
    logger.warn("Failed to verify auth token", { error: err });
    const error = errors.unauthorized("Invalid or expired token");
    res.status(error.statusCode).json({
      success: false,
      error: error.message,
      code: error.code,
    });
  }
}

/**
 * Optional auth middleware - attaches uid if token is valid, continues if not
 */
export async function optionalAuth(
  req: Request,
  _res: Response,
  next: NextFunction,
): Promise<void> {
  const authHeader = req.headers.authorization;

  if (authHeader && authHeader.startsWith("Bearer ")) {
    const idToken = authHeader.split("Bearer ")[1];
    try {
      const decodedToken = await getAuth().verifyIdToken(idToken);
      (req as AuthenticatedRequest).uid = decodedToken.uid;
    } catch {
      logger.debug("Optional auth failed, continuing without uid");
    }
  }

  next();
}
</file>

<file path="src/middleware/latency.ts">
import { Request, Response, NextFunction } from "express";
import { logger } from "firebase-functions/v2";
import { randomUUID } from "crypto";

/**
 * Extended request with latency tracking
 */
export interface TrackedRequest extends Request {
    requestId: string;
    startTime: number;
}

/**
 * Per-request latency logging with correlation IDs.
 * Logs total request duration on response finish.
 *
 * For stage-level timing within handlers, use:
 *   logger.info('Stage: description', { requestId: req.requestId });
 */
export function latencyLogger(
  req: Request,
  res: Response,
  next: NextFunction,
): void {
  const requestId = randomUUID().slice(0, 8);
  const start = Date.now();

  // Attach to request for downstream logging
  (req as TrackedRequest).requestId = requestId;
  (req as TrackedRequest).startTime = start;

  res.on("finish", () => {
    const duration = Date.now() - start;
    logger.info("Request completed", {
      requestId,
      method: req.method,
      path: req.path,
      status: res.statusCode,
      durationMs: duration,
    });
  });

  next();
}

/**
 * Helper to log stage timing within handlers.
 * Usage: logStage(req, 'OpenAI call start');
 */
export function logStage(req: Request, stage: string, extra?: object): void {
  const tracked = req as TrackedRequest;
  const elapsed = Date.now() - tracked.startTime;
  logger.info(`Stage: ${stage}`, {
    requestId: tracked.requestId,
    elapsedMs: elapsed,
    ...extra,
  });
}
</file>

<file path="src/services/backup.ts">
import { getFirestore, Timestamp } from "firebase-admin/firestore";
import { getStorage } from "firebase-admin/storage";
import { logger } from "firebase-functions/v2";
import * as zlib from "zlib";
import { promisify } from "util";
import { errors } from "../utils/errors";
import { BACKUP_CONFIG } from "../config/constants";
import type { BackupPayload } from "../types";

const db = getFirestore();
const gzip = promisify(zlib.gzip);
const gunzip = promisify(zlib.gunzip);

// Increment only if backup format changes
const BACKUP_VERSION = 1;

/**
 * Firestore backup metadata (NO payload here)
 */
export interface BackupDocument {
  version: number;
  storagePath: string;
  sizeBytes: number;
  updatedAt: Timestamp;
}

/**
 * Resolve Cloud Storage bucket explicitly
 */
function getBucket() {
  const bucketName = BACKUP_CONFIG.STORAGE_BUCKET;
  if (!bucketName) {
    throw new Error("STORAGE_BUCKET environment variable is not set");
  }
  return getStorage().bucket(bucketName);
}

/**
 * Storage path for the current backup
 * Overwrites on each backup
 */
function getStoragePath(uid: string): string {
  return `${BACKUP_CONFIG.STORAGE_PATH_PREFIX}/${uid}/backups/${BACKUP_CONFIG.BACKUP_FILENAME}`;
}

/**
 * Save backup for a user
 * 1) Compress JSON
 * 2) Upload to Cloud Storage
 * 3) Store metadata in Firestore
 */
export async function saveBackup(
  uid: string,
  payload: BackupPayload,
): Promise<void> {
  const json = JSON.stringify(payload);
  const compressed = await gzip(Buffer.from(json, "utf-8"));

  const storagePath = getStoragePath(uid);
  const bucket = getBucket();
  const file = bucket.file(storagePath);

  // Upload blob FIRST (atomicity guarantee)
  // NOTE: Do NOT set contentEncoding: "gzip" - this causes Cloud Storage to auto-decompress on download
  await file.save(compressed, {
    contentType: "application/gzip",
  });

  logger.info("Backup uploaded to Cloud Storage", {
    uid,
    storagePath,
    sizeBytes: compressed.length,
  });

  // Write Firestore metadata ONLY
  const backupRef = db
    .collection("users")
    .doc(uid)
    .collection("backup")
    .doc("current");

  await backupRef.set({
    version: BACKUP_VERSION,
    storagePath,
    sizeBytes: compressed.length,
    updatedAt: Timestamp.now(),
  });

  logger.info("Backup metadata written", { uid });
}

/**
 * Load backup for a user
 * Reads metadata ‚Üí downloads blob ‚Üí decompresses
 */
export async function loadBackup(uid: string): Promise<BackupPayload> {
  const backupRef = db
    .collection("users")
    .doc(uid)
    .collection("backup")
    .doc("current");

  const snap = await backupRef.get();
  if (!snap.exists) {
    throw errors.backupNotFound();
  }

  const backup = snap.data() as BackupDocument;

  const bucket = getBucket();
  const file = bucket.file(backup.storagePath);

  const [contents] = await file.download();

  // Check if data is gzip compressed by looking for magic bytes (0x1f 0x8b)
  const isGzipped = contents.length >= 2 && contents[0] === 0x1f && contents[1] === 0x8b;

  let jsonString: string;
  if (isGzipped) {
    const decompressed = await gunzip(contents);
    jsonString = decompressed.toString("utf-8");
  } else {
    // Handle legacy uncompressed backups or auto-decompressed data
    jsonString = contents.toString("utf-8");
    logger.warn("Backup data was not gzip compressed", { uid });
  }

  logger.info("Backup loaded from Cloud Storage", {
    uid,
    version: backup.version,
  });

  return JSON.parse(jsonString);
}

/**
 * Get backup metadata only (no payload)
 */
export async function getBackupInfo(
  uid: string,
): Promise<{
  exists: boolean;
  version?: number;
  updatedAt?: Date;
  sizeBytes?: number;
}> {
  const backupRef = db
    .collection("users")
    .doc(uid)
    .collection("backup")
    .doc("current");

  const snap = await backupRef.get();
  if (!snap.exists) {
    return { exists: false };
  }

  const backup = snap.data() as BackupDocument;

  return {
    exists: true,
    version: backup.version,
    updatedAt: backup.updatedAt.toDate(),
    sizeBytes: backup.sizeBytes,
  };
}
</file>

<file path="src/services/fcm.ts">
import { admin } from "./firestore";
import { logger } from "firebase-functions/v2";
import { LIMITS } from "../config/constants";
import { DeviceDocument } from "../types";

interface SendResult {
  deviceId: string;
  success: boolean;
  error?: string;
}

export async function sendPushNotification(
  fcmToken: string,
  title: string,
  body: string,
  link?: string,
): Promise<{ success: boolean; error?: string }> {
  try {
    await admin.messaging().send({
      token: fcmToken,
      notification: {
        title,
        body,
      },
      data: link ? { link } : undefined,
      android: {
        priority: "high",
        notification: {
          channelId: "weight_reminders",
        },
      },
      apns: {
        payload: {
          aps: {
            sound: "default",
            badge: 1,
          },
        },
      },
    });
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    logger.warn(`FCM send failed: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
}

export async function sendBatchNotifications(
  devices: DeviceDocument[],
  title: string,
  body: string,
  link?: string,
): Promise<SendResult[]> {
  const results: SendResult[] = [];

  // Process in batches to respect FCM limits
  for (let i = 0; i < devices.length; i += LIMITS.FCM_BATCH_SIZE) {
    const batch = devices.slice(i, i + LIMITS.FCM_BATCH_SIZE);

    const batchPromises = batch.map(async (device) => {
      const result = await sendPushNotification(device.fcmToken, title, body, link);
      return {
        deviceId: device.deviceId,
        success: result.success,
        error: result.error,
      };
    });

    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults);
  }

  const successCount = results.filter((r) => r.success).length;
  const failCount = results.length - successCount;
  logger.info(`Batch send complete: ${successCount} success, ${failCount} failed`);

  return results;
}
</file>

<file path="src/services/firestore.ts">
import * as admin from "firebase-admin";
import { logger } from "firebase-functions/v2";
import { COLLECTIONS, LIMITS } from "../config/constants";
import { DeviceDocument, NudgeDocument } from "../types";

// Initialize Firebase Admin if not already initialized
if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();

// Device operations
export async function upsertDevice(
  deviceId: string,
  fcmToken: string,
  platform: "ios" | "android",
): Promise<void> {
  const deviceRef = db.collection(COLLECTIONS.DEVICES).doc(deviceId);
  const now = admin.firestore.Timestamp.now();

  const deviceDoc = await deviceRef.get();

  if (deviceDoc.exists) {
    // Update existing device
    await deviceRef.update({
      fcmToken,
      platform,
      lastSeenAt: now,
    });
    logger.info(`Updated device: ${deviceId}`);
  } else {
    // Create new device
    const newDevice: DeviceDocument = {
      deviceId,
      fcmToken,
      platform,
      createdAt: now,
      lastSeenAt: now,
    };
    await deviceRef.set(newDevice);
    logger.info(`Registered new device: ${deviceId}`);
  }
}

export async function getActiveDevices(): Promise<DeviceDocument[]> {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - LIMITS.DEVICE_ACTIVE_DAYS);
  const cutoffTimestamp = admin.firestore.Timestamp.fromDate(cutoffDate);

  const snapshot = await db
    .collection(COLLECTIONS.DEVICES)
    .where("lastSeenAt", ">=", cutoffTimestamp)
    .get();

  return snapshot.docs.map((doc) => doc.data() as DeviceDocument);
}

// Nudge operations
export async function logNudge(nudge: Omit<NudgeDocument, "sentAt">): Promise<void> {
  const nudgeData: NudgeDocument = {
    ...nudge,
    sentAt: admin.firestore.Timestamp.now(),
  };

  await db.collection(COLLECTIONS.NUDGES).add(nudgeData);
  logger.info(`Logged nudge for device: ${nudge.deviceId}`, {
    status: nudge.status,
  });
}

export { db, admin };
</file>

<file path="src/services/user.ts">
import { getFirestore, FieldValue, Timestamp } from "firebase-admin/firestore";
import { logger } from "firebase-functions/v2";
import { errors } from "../utils/errors";

const db = getFirestore();

// Default free credits for new users
const DEFAULT_FREE_CREDITS = 20;

/**
 * User document structure
 */
export interface UserDocument {
    aiCredits: number;
    totalGranted: number;
    totalUsed: number;
    createdAt: Timestamp;
    lastActiveAt: Timestamp;
}

/**
 * Initialize a new user with free credits
 * Called on first authentication
 */
export async function initializeUser(uid: string): Promise<UserDocument> {
  const userRef = db.collection("users").doc(uid);

  const existingUser = await userRef.get();
  if (existingUser.exists) {
    logger.info(`User ${uid} already exists, returning existing data`);
    return existingUser.data() as UserDocument;
  }

  const now = Timestamp.now();
  const userData: UserDocument = {
    aiCredits: DEFAULT_FREE_CREDITS,
    totalGranted: DEFAULT_FREE_CREDITS,
    totalUsed: 0,
    createdAt: now,
    lastActiveAt: now,
  };

  await userRef.set(userData);
  logger.info(`Initialized new user ${uid} with ${DEFAULT_FREE_CREDITS} credits`);

  return userData;
}

/**
 * Get or create user data
 */
export async function getOrCreateUser(uid: string): Promise<UserDocument> {
  const userRef = db.collection("users").doc(uid);
  const userDoc = await userRef.get();

  if (!userDoc.exists) {
    return initializeUser(uid);
  }

  // Update last active timestamp
  await userRef.update({ lastActiveAt: FieldValue.serverTimestamp() });

  return userDoc.data() as UserDocument;
}

/**
 * Get current credit balance
 */
export async function getCredits(uid: string): Promise<number> {
  const user = await getOrCreateUser(uid);
  return user.aiCredits;
}

/**
 * Deduct one credit from user balance
 * Uses transaction to prevent race conditions
 * Throws INSUFFICIENT_CREDITS if balance is 0
 */
export async function deductCredit(uid: string): Promise<number> {
  const userRef = db.collection("users").doc(uid);

  const newBalance = await db.runTransaction(async (transaction) => {
    const userDoc = await transaction.get(userRef);

    if (!userDoc.exists) {
      // Initialize user first
      const now = Timestamp.now();
      const userData: UserDocument = {
        aiCredits: DEFAULT_FREE_CREDITS,
        totalGranted: DEFAULT_FREE_CREDITS,
        totalUsed: 0,
        createdAt: now,
        lastActiveAt: now,
      };
      transaction.set(userRef, userData);
      // Deduct one credit
      transaction.update(userRef, {
        aiCredits: DEFAULT_FREE_CREDITS - 1,
        totalUsed: 1,
        lastActiveAt: FieldValue.serverTimestamp(),
      });
      return DEFAULT_FREE_CREDITS - 1;
    }

    const userData = userDoc.data() as UserDocument;

    if (userData.aiCredits <= 0) {
      throw errors.insufficientCredits();
    }

    const newCredits = userData.aiCredits - 1;
    transaction.update(userRef, {
      aiCredits: newCredits,
      totalUsed: FieldValue.increment(1),
      lastActiveAt: FieldValue.serverTimestamp(),
    });

    return newCredits;
  });

  logger.info(`Deducted credit for user ${uid}, remaining: ${newBalance}`);
  return newBalance;
}

/**
 * Add credits to user balance (for future admin/payment use)
 */
export async function addCredits(uid: string, amount: number): Promise<number> {
  const userRef = db.collection("users").doc(uid);

  await userRef.update({
    aiCredits: FieldValue.increment(amount),
    totalGranted: FieldValue.increment(amount),
    lastActiveAt: FieldValue.serverTimestamp(),
  });

  const updated = await userRef.get();
  const credits = (updated.data() as UserDocument).aiCredits;

  logger.info(`Added ${amount} credits to user ${uid}, new balance: ${credits}`);
  return credits;
}
</file>

<file path="src/services/vision.ts">
import OpenAI from "openai";
import * as crypto from "crypto";
import { logger } from "firebase-functions/v2";
import { defineString } from "firebase-functions/params";
import {
  VisionPassResult,
  VisionErrorSchema,
  FoodAnalysisRecord,
  NutritionData,
  PerceptionResult,
  PerceptionResultSchema,
  NutritionResult,
  NutritionResultSchema,
  PerceptionItem,
} from "../types";
import { VISION_CONFIG, COLLECTIONS } from "../config/constants";
import { errors } from "../utils/errors";
import { db, admin } from "./firestore";

// Define the API key as a Firebase parameter
const openaiApiKey = defineString("OPENAI_API_KEY");

// =============================================================================
// 2-STAGE PROMPTS
// =============================================================================

/* eslint-disable max-len */

/**
 * Stage 1: Vision Perception
 * Only what requires pixels. Nothing else.
 */
const PERCEPTION_PROMPT = `You are a food perception system.

Task:
From the image, identify up to 5 distinct food items and estimate their
approximate edible weight in grams.

Rules:
- Focus on visual identification only.
- Be conservative with weight estimates.
- Do NOT estimate nutrition.
- Do NOT explain reasoning.
- Do NOT infer ingredients or cooking method.
- Output JSON only.

Response format:
{
  "items": [
    {
      "foodName": "string",
      "estimatedWeight_g": number,
      "confidence": number between 0 and 1
    }
  ]
}

Error format:
{
  "error": "description",
  "errorType": "NOT_FOOD" | "BLURRY" | "LOW_CONFIDENCE" | "MULTIPLE_ITEMS"
}`;

/**
 * Stage 2: Nutrition Reasoning (Text-only)
 * Statistical nutrition estimation from identified items.
 */
const NUTRITION_PROMPT = `You are a nutrition estimation system.

Given the following food items and their estimated weights,
estimate typical home-style nutrition values.

Rules:
- Use typical preparation assumptions.
- Be conservative.
- No explanations.
- Output JSON only.

Response format:
{
  "items": [
    {
      "foodName": "string",
      "calories": number,
      "protein": number,
      "carbohydrates": number,
      "fat": number,
      "fiber": number
    }
  ]
}`;

/* eslint-enable max-len */

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Compute SHA-256 hash of image with byte length salt for collision safety
 */
function computeImageHash(imageBase64: string): { hash: string; byteLength: number } {
  const buffer = Buffer.from(imageBase64, "base64");
  const byteLength = buffer.length;
  const saltedInput = `${imageBase64}:${byteLength}`;
  const hash = crypto.createHash("sha256").update(saltedInput).digest("hex");
  return { hash, byteLength };
}

/**
 * Clean markdown code blocks from LLM response
 */
function cleanJsonResponse(content: string): string {
  let clean = content.trim();
  if (clean.startsWith("```json")) {
    clean = clean.slice(7);
  }
  if (clean.startsWith("```")) {
    clean = clean.slice(3);
  }
  if (clean.endsWith("```")) {
    clean = clean.slice(0, -3);
  }
  return clean.trim();
}

/**
 * Normalize food name between stages
 * - lowercase
 * - trim
 * - basic plural handling
 */
function normalizeFoodName(name: string): string {
  let normalized = name.toLowerCase().trim();
  // Simple plural normalization
  if (normalized.endsWith("ies") && normalized.length > 4) {
    normalized = normalized.slice(0, -3) + "y";
  } else if (normalized.endsWith("es") && normalized.length > 3) {
    normalized = normalized.slice(0, -2);
  } else if (normalized.endsWith("s") && normalized.length > 2) {
    normalized = normalized.slice(0, -1);
  }
  return normalized;
}

// =============================================================================
// Error Handling
// =============================================================================

function handleAiError(errorMessage: string, errorType?: string): never {
  const lowerMessage = errorMessage.toLowerCase();

  if (errorType) {
    switch (errorType) {
    case "NOT_FOOD":
      throw errors.notFood(errorMessage);
    case "BLURRY":
      throw errors.imageTooBlurry();
    case "MULTIPLE_ITEMS":
      throw errors.multipleFoods();
    case "LOW_CONFIDENCE":
      throw errors.lowConfidence();
    default:
      throw errors.analysisFailed(errorMessage);
    }
  }

  if (lowerMessage.includes("not food") || lowerMessage.includes("no food")) {
    throw errors.notFood(errorMessage);
  }
  if (lowerMessage.includes("blurry") || lowerMessage.includes("unclear")) {
    throw errors.imageTooBlurry();
  }
  if (lowerMessage.includes("cannot identify") || lowerMessage.includes("not sure")) {
    throw errors.lowConfidence();
  }

  throw errors.analysisFailed(errorMessage);
}

// =============================================================================
// Stage 1: Vision Perception
// =============================================================================

interface PerceptionOutput {
  rawText: string;
  parsed: PerceptionResult;
  durationMs: number;
}

/**
 * Stage 1: Identify food items and estimate weights from image.
 * Uses vision model with tight token limit.
 */
async function runVisionPerception(
  openai: OpenAI,
  imageBase64: string,
): Promise<PerceptionOutput> {
  const startTime = Date.now();

  const response = await openai.chat.completions.create({
    model: VISION_CONFIG.MODEL,
    max_completion_tokens: VISION_CONFIG.PERCEPTION_MAX_TOKENS,
    messages: [
      {
        role: "user",
        content: [
          { type: "text", text: PERCEPTION_PROMPT },
          {
            type: "image_url",
            image_url: {
              url: `data:image/jpeg;base64,${imageBase64}`,
              detail: "low",
            },
          },
        ],
      },
    ],
  });

  const durationMs = Date.now() - startTime;
  const rawText = response.choices[0]?.message?.content;

  if (!rawText) {
    throw errors.aiServiceError();
  }

  const cleanContent = cleanJsonResponse(rawText);
  let parsed: unknown;

  try {
    parsed = JSON.parse(cleanContent);
  } catch {
    logger.error("Failed to parse perception response", { rawText });
    throw errors.parseError();
  }

  // Check for error response
  const errorResult = VisionErrorSchema.safeParse(parsed);
  if (errorResult.success) {
    handleAiError(errorResult.data.error, errorResult.data.errorType);
  }

  // Parse as perception result
  const successResult = PerceptionResultSchema.safeParse(parsed);
  if (!successResult.success) {
    logger.error("Perception response validation failed", {
      errors: successResult.error.issues,
      rawText,
    });
    throw errors.parseError();
  }

  logger.info("Stage 1 (Perception) complete", {
    itemCount: successResult.data.items.length,
    durationMs,
  });

  return { rawText, parsed: successResult.data, durationMs };
}

// =============================================================================
// Stage 2: Nutrition Reasoning (Text-only)
// =============================================================================

interface NutritionOutput {
  rawText: string;
  parsed: NutritionResult;
  durationMs: number;
}

/**
 * Stage 2: Estimate nutrition from identified food items.
 * Text-only model call - no image context.
 */
async function runNutritionText(
  openai: OpenAI,
  items: PerceptionItem[],
): Promise<NutritionOutput> {
  const startTime = Date.now();

  // Prepare input with normalized food names
  const input = items.map((item) => ({
    foodName: item.foodName,
    estimatedWeight_g: item.estimatedWeight_g,
  }));

  const response = await openai.chat.completions.create({
    model: VISION_CONFIG.TEXT_MODEL, // Explicitly mark as text-only
    max_completion_tokens: VISION_CONFIG.NUTRITION_MAX_TOKENS,
    messages: [
      {
        role: "user",
        content: `${NUTRITION_PROMPT}\n\nInput:\n${JSON.stringify(input, null, 2)}`,
      },
    ],
  });

  const durationMs = Date.now() - startTime;
  const rawText = response.choices[0]?.message?.content;

  if (!rawText) {
    throw errors.aiServiceError();
  }

  const cleanContent = cleanJsonResponse(rawText);
  let parsed: unknown;

  try {
    parsed = JSON.parse(cleanContent);
  } catch {
    logger.error("Failed to parse nutrition response", { rawText });
    throw errors.parseError();
  }

  // Parse as nutrition result
  const successResult = NutritionResultSchema.safeParse(parsed);
  if (!successResult.success) {
    logger.error("Nutrition response validation failed", {
      errors: successResult.error.issues,
      rawText,
    });
    throw errors.parseError();
  }

  logger.info("Stage 2 (Nutrition) complete", {
    itemCount: successResult.data.items.length,
    durationMs,
  });

  return { rawText, parsed: successResult.data, durationMs };
}

// =============================================================================
// Confidence Gating
// =============================================================================

/**
 * Gate Stage 2 execution based on perception confidence.
 * Throws LOW_CONFIDENCE if any item is below threshold.
 */
function validatePerceptionConfidence(items: PerceptionItem[]): void {
  const minConfidence = Math.min(...items.map((i) => i.confidence));

  if (minConfidence < VISION_CONFIG.MIN_CONFIDENCE) {
    logger.warn("Perception confidence too low, aborting Stage 2", {
      minConfidence,
      threshold: VISION_CONFIG.MIN_CONFIDENCE,
    });
    throw errors.lowConfidence();
  }
}

// =============================================================================
// Merge Results to VisionPassResult (backward compatibility)
// =============================================================================

/**
 * Merge perception and nutrition outputs into VisionPassResult format.
 * This maintains backward compatibility with existing persistence and aggregation.
 */
function mergeToVisionPassResult(
  perception: PerceptionResult,
  nutrition: NutritionResult,
): VisionPassResult {
  // Create a map of normalized food names to nutrition data
  const nutritionMap = new Map<string, NutritionResult["items"][0]>();
  for (const item of nutrition.items) {
    nutritionMap.set(normalizeFoodName(item.foodName), item);
  }

  // Merge perception items with nutrition data
  const items = perception.items.map((pItem) => {
    const normalizedName = normalizeFoodName(pItem.foodName);
    const nItem = nutritionMap.get(normalizedName);

    // Default nutrition if not found (shouldn't happen but be safe)
    const calories = nItem?.calories ?? 0;
    const protein = nItem?.protein ?? 0;
    const carbohydrates = nItem?.carbohydrates ?? 0;
    const fat = nItem?.fat ?? 0;
    const fiber = nItem?.fiber ?? 0;

    return {
      foodName: pItem.foodName,
      estimatedWeight_g: pItem.estimatedWeight_g,
      calories,
      protein,
      carbohydrates,
      fat,
      fiber,
      // Placeholder canonical data (not used in 2-stage mode)
      _canonical: {
        cuisine: "unknown",
        baseIngredients: [],
        cookingMethod: "unknown",
        density: "medium" as const,
        moisture: "moist" as const,
        processingLevel: "minimal" as const,
      },
      _debug: {
        confidence: pItem.confidence,
        visualCues: [],
      },
    };
  });

  const totalWeight = items.reduce((sum, i) => sum + i.estimatedWeight_g, 0);
  const totalCalories = items.reduce((sum, i) => sum + i.calories, 0);

  return {
    items,
    totalWeight_g: totalWeight,
    totalCalories,
  };
}

// =============================================================================
// Persistence
// =============================================================================

async function persistAnalysis(record: FoodAnalysisRecord): Promise<void> {
  try {
    await db.collection(COLLECTIONS.FOOD_ANALYSES).add({
      ...record,
      createdAt: admin.firestore.Timestamp.fromDate(record.createdAt),
    });
    logger.info("Persisted food analysis", {
      imageHash: record.imageHash,
      status: record.status,
      itemCount: record.finalResult.items.length,
    });
  } catch (err) {
    logger.error("Failed to persist food analysis", { error: err });
    // Don't throw - persistence failure shouldn't block response
  }
}

// =============================================================================
// Legacy Aggregation (Backward Compatibility)
// =============================================================================

function aggregateToLegacy(result: VisionPassResult): NutritionData {
  const totalProtein = result.items.reduce((sum, i) => sum + i.protein, 0);
  const totalCarbs = result.items.reduce((sum, i) => sum + i.carbohydrates, 0);
  const totalFat = result.items.reduce((sum, i) => sum + i.fat, 0);
  const totalFiber = result.items.reduce((sum, i) => sum + i.fiber, 0);

  const foodName = result.items.length === 1 ?
    result.items[0].foodName :
    "Mixed meal";

  return {
    foodName,
    calories: result.totalCalories,
    protein: Math.round(totalProtein * 10) / 10,
    carbohydrates: Math.round(totalCarbs * 10) / 10,
    fat: Math.round(totalFat * 10) / 10,
    fiber: Math.round(totalFiber * 10) / 10,
    estimatedServingSize: `${result.totalWeight_g}g`,
  };
}

// =============================================================================
// Main Entry Point: 2-Stage Pipeline
// =============================================================================

export async function analyzeFood(imageBase64: string): Promise<NutritionData> {
  const startTime = Date.now();
  const apiKey = openaiApiKey.value();

  if (!apiKey) {
    throw errors.aiConfigError();
  }

  const openai = new OpenAI({ apiKey });
  const { hash: imageHash, byteLength: imageByteLength } = computeImageHash(imageBase64);

  logger.info("Starting 2-stage food analysis", { imageHash });

  // ==========================================================================
  // Stage 1: Vision Perception
  // ==========================================================================
  let perception: PerceptionOutput;
  try {
    perception = await runVisionPerception(openai, imageBase64);
  } catch (err) {
    logger.error("Stage 1 (Perception) failed", { error: err });
    throw err;
  }

  // ==========================================================================
  // Confidence Gate
  // ==========================================================================
  validatePerceptionConfidence(perception.parsed.items);

  // ==========================================================================
  // Stage 2: Nutrition Reasoning (Text-only)
  // ==========================================================================
  let nutrition: NutritionOutput;
  try {
    nutrition = await runNutritionText(openai, perception.parsed.items);
  } catch (err) {
    logger.error("Stage 2 (Nutrition) failed", { error: err });
    throw err;
  }

  // ==========================================================================
  // Merge Results
  // ==========================================================================
  const finalResult = mergeToVisionPassResult(perception.parsed, nutrition.parsed);
  const totalDurationMs = Date.now() - startTime;

  logger.info("2-stage analysis complete", {
    itemCount: finalResult.items.length,
    totalCalories: finalResult.totalCalories,
    perceptionMs: perception.durationMs,
    nutritionMs: nutrition.durationMs,
    totalMs: totalDurationMs,
  });

  // ==========================================================================
  // Persist Analysis Record
  // ==========================================================================
  const record: FoodAnalysisRecord = {
    imageHash,
    imageByteLength,
    model: VISION_CONFIG.MODEL,
    promptVersion: VISION_CONFIG.PROMPT_VERSION,

    // Stage 1: Perception
    perceptionRawText: perception.rawText,
    perceptionParsed: perception.parsed,
    perceptionDurationMs: perception.durationMs,

    // Stage 2: Nutrition
    nutritionRawText: nutrition.rawText,
    nutritionParsed: nutrition.parsed,
    nutritionDurationMs: nutrition.durationMs,

    // Final result
    status: "TWO_STAGE",
    finalResult,
    createdAt: new Date(),
    durationMs: totalDurationMs,
  };

  await persistAnalysis(record);

  // Aggregate to legacy format for backward compatibility
  return aggregateToLegacy(finalResult);
}

// =============================================================================
// Quick Scan: Single-Stage Lightweight Analysis
// =============================================================================

const DAILY_CALORIE_TARGET = 2000;
const AVG_KCAL_PER_GRAM = 1.5; // Conservative average for mixed foods

/**
 * Map numeric confidence to categorical level
 */
function mapConfidenceLevel(confidence: number): "high" | "medium" | "low" {
  if (confidence >= 0.8) return "high";
  if (confidence >= 0.6) return "medium";
  return "low";
}

/**
 * Generate one-liner message about calorie percentage
 */
function generateCalorieMessage(calories: number): string {
  const percentage = Math.round((calories / DAILY_CALORIE_TARGET) * 100);
  return `That's ${percentage}% of a typical daily target`;
}

/**
 * Quick food scan - lightweight single-stage analysis
 * Returns simplified results: food name, confidence, estimated calories, one-liner
 *
 * Uses only Stage 1 (perception) for speed.
 * Does NOT persist to Firestore.
 */
export async function quickAnalyzeFood(imageBase64: string): Promise<{
  foodName: string;
  confidence: "high" | "medium" | "low";
  calories: number;
  message: string;
}> {
  const startTime = Date.now();
  const apiKey = openaiApiKey.value();

  if (!apiKey) {
    throw errors.aiConfigError();
  }

  const openai = new OpenAI({ apiKey });
  const { hash: imageHash } = computeImageHash(imageBase64);

  logger.info("Starting quick food scan", { imageHash });

  // Run Stage 1 only (perception)
  const perception = await runVisionPerception(openai, imageBase64);

  // Aggregate items if multiple detected
  const items = perception.parsed.items;
  const totalWeight = items.reduce((sum, i) => sum + i.estimatedWeight_g, 0);
  const avgConfidence = items.reduce((sum, i) => sum + i.confidence, 0) / items.length;

  // Generate food name
  const foodName = items.length === 1 ?
    items[0].foodName :
    items.map((i) => i.foodName).join(" + ");

  // Rough calorie estimate based on weight
  const calories = Math.round(totalWeight * AVG_KCAL_PER_GRAM);

  const durationMs = Date.now() - startTime;

  logger.info("Quick scan complete", {
    foodName,
    calories,
    confidence: mapConfidenceLevel(avgConfidence),
    durationMs,
  });

  return {
    foodName,
    confidence: mapConfidenceLevel(avgConfidence),
    calories,
    message: generateCalorieMessage(calories),
  };
}
</file>

<file path="src/types/index.ts">
// Type definitions for the weight-tracking backend

// Re-export vision schemas
export * from "./visionSchemas";
// Device registration types
export interface DeviceRegistrationRequest {
    deviceId: string;
    fcmToken: string;
    platform: "ios" | "android";
}

export interface DeviceDocument {
    deviceId: string;
    fcmToken: string;
    platform: "ios" | "android";
    createdAt: FirebaseFirestore.Timestamp;
    lastSeenAt: FirebaseFirestore.Timestamp;
}

export interface DeviceRegistrationResponse {
    success: boolean;
    message: string;
}

// Nudge types
export interface NudgeDocument {
    deviceId: string;
    sentAt: FirebaseFirestore.Timestamp;
    status: "success" | "failed";
    title: string;
    body: string;
    error?: string;
}

// Food analysis types
export interface FoodAnalysisRequest {
    deviceId: string;
    image?: string; // Base64 encoded image
}

export interface NutritionData {
    foodName: string;
    calories: number;
    protein: number;
    carbohydrates: number;
    fat: number;
    fiber: number;
    estimatedServingSize: string;
}

export interface FoodAnalysisResponse {
    success: boolean;
    nutrition?: NutritionData;
    error?: string;
}

// Quick scan response (lightweight food identification)
export interface QuickScanResponse {
    foodName: string;
    confidence: "high" | "medium" | "low";
    calories: number;
    message: string;
}

// API Error response
export interface ApiErrorResponse {
    success: false;
    error: string;
    code?: string;
}

// Backup payload types
// Matches backupSchema in utils/validation.ts
export interface BackupPayload {
    weightEntries?: unknown[];
    foodLogs?: unknown[];
    streaks?: Record<string, unknown>;
    metadata?: Record<string, unknown>;
}
</file>

<file path="src/types/visionSchemas.ts">
import { z } from "zod";

// =============================================================================
// Error Types
// =============================================================================

export const VisionErrorTypeSchema = z.enum([
  "NOT_FOOD",
  "BLURRY",
  "LOW_CONFIDENCE",
  "MULTIPLE_ITEMS",
]);
export type VisionErrorType = z.infer<typeof VisionErrorTypeSchema>;

export const VisionErrorSchema = z.object({
  error: z.string(),
  errorType: VisionErrorTypeSchema,
});
export type VisionError = z.infer<typeof VisionErrorSchema>;

// =============================================================================
// Debug / Confidence
// =============================================================================

export const ItemDebugSchema = z.object({
  confidence: z.number().min(0).max(1),
  visualCues: z.array(z.string()),
});
export type ItemDebug = z.infer<typeof ItemDebugSchema>;

// =============================================================================
// 2-Stage Architecture: Perception (Stage 1)
// =============================================================================

export const PerceptionItemSchema = z.object({
  foodName: z.string(),
  estimatedWeight_g: z.number().positive(),
  confidence: z.number().min(0).max(1),
});
export type PerceptionItem = z.infer<typeof PerceptionItemSchema>;

export const PerceptionResultSchema = z.object({
  items: z.array(PerceptionItemSchema).min(1).max(5),
});
export type PerceptionResult = z.infer<typeof PerceptionResultSchema>;

// =============================================================================
// 2-Stage Architecture: Nutrition (Stage 2)
// =============================================================================

export const NutritionItemSchema = z.object({
  foodName: z.string(),
  calories: z.number().nonnegative(),
  protein: z.number().nonnegative(),
  carbohydrates: z.number().nonnegative(),
  fat: z.number().nonnegative(),
  fiber: z.number().nonnegative(),
});
export type NutritionItem = z.infer<typeof NutritionItemSchema>;

export const NutritionResultSchema = z.object({
  items: z.array(NutritionItemSchema).min(1).max(5),
});
export type NutritionResult = z.infer<typeof NutritionResultSchema>;

// =============================================================================
// Food Item (per-item nutrition)
// =============================================================================

export const FoodItemSchema = z.object({
  foodName: z.string(),
  estimatedWeight_g: z.number().positive(),
  calories: z.number().nonnegative(),
  protein: z.number().nonnegative(),
  carbohydrates: z.number().nonnegative(),
  fat: z.number().nonnegative(),
  fiber: z.number().nonnegative(),
  // Latent canonical attributes (not exposed in reasoning)
  _canonical: z.object({
    cuisine: z.string(),
    baseIngredients: z.array(z.string()),
    cookingMethod: z.string(),
    density: z.enum(["low", "medium", "high"]),
    moisture: z.enum(["dry", "moist", "wet"]),
    processingLevel: z.enum(["raw", "minimal", "processed", "ultra-processed"]),
  }),
  _debug: ItemDebugSchema,
});
export type FoodItem = z.infer<typeof FoodItemSchema>;

// =============================================================================
// Vision Pass Result (multi-item response)
// =============================================================================

export const VisionPassResultSchema = z.object({
  items: z.array(FoodItemSchema).min(1).max(5),
  totalWeight_g: z.number().positive(),
  totalCalories: z.number().nonnegative(),
});
export type VisionPassResult = z.infer<typeof VisionPassResultSchema>;

// =============================================================================
// Combined Response (success or error)
// =============================================================================

export const VisionResponseSchema = z.union([
  VisionPassResultSchema,
  VisionErrorSchema,
]);
export type VisionResponse = z.infer<typeof VisionResponseSchema>;

// =============================================================================
// Persistence: Analysis Record (Firestore)
// =============================================================================

export const AnalysisStatusSchema = z.enum([
  "SINGLE_PASS",
  "TWO_STAGE",
  "TWO_PASS_AGREED",
  "TWO_PASS_DIVERGED",
]);
export type AnalysisStatus = z.infer<typeof AnalysisStatusSchema>;

export const DivergenceReasonSchema = z.enum([
  "CALORIES",
  "WEIGHT",
  "ITEM_MISMATCH",
]).optional();
export type DivergenceReason = z.infer<typeof DivergenceReasonSchema>;

export const FoodAnalysisRecordSchema = z.object({
  // Identity
  imageHash: z.string(),
  imageByteLength: z.number(), // Salt for hash collision safety

  // Model metadata
  model: z.string(),
  promptVersion: z.string(),

  // 2-Stage Architecture: Perception (Stage 1)
  perceptionRawText: z.string().optional(),
  perceptionParsed: PerceptionResultSchema.optional(),
  perceptionDurationMs: z.number().optional(),

  // 2-Stage Architecture: Nutrition (Stage 2)
  nutritionRawText: z.string().optional(),
  nutritionParsed: NutritionResultSchema.optional(),
  nutritionDurationMs: z.number().optional(),

  // Legacy: Pass 1 (single pass mode)
  pass1RawText: z.string().optional(),
  pass1Parsed: VisionPassResultSchema.optional(),

  // Legacy: Pass 2 (optional - only if triggered)
  pass2RawText: z.string().optional(),
  pass2Parsed: VisionPassResultSchema.optional(),

  // Final result
  status: AnalysisStatusSchema,
  divergenceReason: DivergenceReasonSchema,
  finalResult: VisionPassResultSchema,

  // Timestamps
  createdAt: z.date(),
  durationMs: z.number(),
});
export type FoodAnalysisRecord = z.infer<typeof FoodAnalysisRecordSchema>;

// =============================================================================
// Helper: Check if response is an error
// =============================================================================

export function isVisionError(
  response: VisionResponse,
): response is VisionError {
  return "error" in response && "errorType" in response;
}
</file>

<file path="src/utils/errors.ts">
import { Response } from "express";
import { logger } from "firebase-functions/v2";

export class ApiError extends Error {
  constructor(
    public statusCode: number,
    message: string,
    public code?: string,
  ) {
    super(message);
    this.name = "ApiError";
  }
}

export function handleError(error: unknown, res: Response): void {
  if (error instanceof ApiError) {
    logger.warn(`API Error: ${error.message}`, { code: error.code });
    res.status(error.statusCode).json({
      success: false,
      error: error.message,
      code: error.code,
    });
    return;
  }

  if (error instanceof Error) {
    logger.error(`Unexpected error: ${error.message}`, { stack: error.stack });
    res.status(500).json({
      success: false,
      error: "Internal server error",
    });
    return;
  }

  logger.error("Unknown error type", { error });
  res.status(500).json({
    success: false,
    error: "Internal server error",
  });
}

// Common API error factories (lowercase to satisfy new-cap rule)
export const errors = {
  invalidRequest: (message: string) =>
    new ApiError(400, message, "INVALID_REQUEST"),
  deviceNotFound: () =>
    new ApiError(404, "Device not found", "DEVICE_NOT_FOUND"),
  imageTooLarge: (maxSize: number) =>
    new ApiError(
      413,
      `Image exceeds maximum size of ${maxSize / 1024 / 1024}MB`,
      "IMAGE_TOO_LARGE",
    ),
  unsupportedFormat: (formats: string[]) =>
    new ApiError(
      415,
      `Unsupported image format. Supported: ${formats.join(", ")}`,
      "UNSUPPORTED_FORMAT",
    ),
  analysisFailed: (reason: string) =>
    new ApiError(422, `Food analysis failed: ${reason}`, "ANALYSIS_FAILED"),
  notFood: (description?: string) =>
    new ApiError(
      422,
      description || "The image does not appear to contain food",
      "NOT_FOOD",
    ),
  imageTooBlurry: () =>
    new ApiError(
      422,
      "The image is too blurry or unclear to analyze",
      "IMAGE_TOO_BLURRY",
    ),
  multipleFoods: () =>
    new ApiError(
      422,
      "Multiple food items detected. Please capture one item at a time",
      "MULTIPLE_FOODS",
    ),
  lowConfidence: () =>
    new ApiError(
      422,
      "Could not confidently identify the food. Try a clearer photo",
      "LOW_CONFIDENCE",
    ),
  aiServiceError: () =>
    new ApiError(
      503,
      "AI service temporarily unavailable. Please try again",
      "AI_SERVICE_ERROR",
    ),
  aiConfigError: () =>
    new ApiError(
      500,
      "AI service configuration error",
      "AI_CONFIG_ERROR",
    ),
  parseError: () =>
    new ApiError(
      500,
      "Failed to parse AI response",
      "PARSE_ERROR",
    ),
  rateLimited: () =>
    new ApiError(429, "Too many requests", "RATE_LIMITED"),
  internalError: () =>
    new ApiError(500, "Internal server error", "INTERNAL_ERROR"),
  // Auth & Credits errors
  unauthorized: (message?: string) =>
    new ApiError(401, message || "Unauthorized", "UNAUTHORIZED"),
  insufficientCredits: () =>
    new ApiError(402, "Insufficient AI credits", "INSUFFICIENT_CREDITS"),
  backupNotFound: () =>
    new ApiError(404, "No backup found for this user", "BACKUP_NOT_FOUND"),
  storageError: (message?: string) =>
    new ApiError(500, message || "Storage operation failed", "STORAGE_ERROR"),
};
</file>

<file path="src/utils/validation.ts">
import { z } from "zod";

// Device registration validation schema
export const deviceRegistrationSchema = z.object({
  deviceId: z
    .string()
    .min(1, "deviceId is required")
    .max(256, "deviceId too long"),
  fcmToken: z
    .string()
    .min(1, "fcmToken is required")
    .max(4096, "fcmToken too long"),
  platform: z.enum(["ios", "android"], {
    errorMap: () => ({ message: "platform must be 'ios' or 'android'" }),
  }),
});

// Food analysis validation schema (deviceId now optional, auth provides uid)
export const foodAnalysisSchema = z.object({
  image: z
    .string()
    .min(1, "image is required")
    .optional(),
});

// Backup data validation schema
export const backupSchema = z.object({
  weightEntries: z.array(z.unknown()).optional(),
  foodLogs: z.array(z.unknown()).optional(),
  streaks: z.record(z.unknown()).optional(),
  metadata: z.record(z.unknown()).optional(),
});

// Type exports from schemas
export type DeviceRegistrationInput = z.infer<typeof deviceRegistrationSchema>;
export type FoodAnalysisInput = z.infer<typeof foodAnalysisSchema>;
export type BackupInput = z.infer<typeof backupSchema>;

// Validation helper
export function validateInput<T>(
  schema: z.ZodSchema<T>,
  data: unknown,
): { success: true; data: T } | { success: false; error: string } {
  const result = schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  const errorMessage = result.error.errors
    .map((e) => `${e.path.join(".")}: ${e.message}`)
    .join(", ");
  return { success: false, error: errorMessage };
}
</file>

<file path="src/api.ts">
import express, { Request, Response } from "express";
import cors from "cors";
import { latencyLogger } from "./middleware/latency";
import { analyzeFoodImage } from "./handlers/analyzeFoodImage";
import { createBackup, restoreBackup, getBackupStatus } from "./handlers/backup";
import { getCreditsHandler, getUserProfile } from "./handlers/credits";
import { registerDevice } from "./handlers/registerDevice";
import { quickScan } from "./handlers/quickScan";

const app = express();

// Health check BEFORE heavy middleware (fast path)
app.get("/health", (_req: Request, res: Response) => {
  res.json({ status: "ok", version: "1.0.0" });
});

// Middleware
app.use(cors({ origin: true }));
app.use(express.json({ limit: "6mb" })); // Matches 5MB image limit + overhead
app.use(latencyLogger);

/**
 * Route Map (v1 - stable)
 * -----------------------
 * POST /register-device  - Device registration (no auth)
 * POST /analyze-food     - Food image analysis (auth required)
 * POST /quick-scan       - Quick food scan (auth required)
 * POST /backup           - Create backup (auth required)
 * POST /restore          - Restore backup (auth required)
 * GET  /backup-status    - Backup metadata (auth required)
 * GET  /credits          - Credit balance (auth required)
 * GET  /user/me          - User profile (auth required)
 *
 * Route paths are considered stable for v1 and will not change
 * without version bump.
 */

// Public routes
app.post("/register-device", registerDevice);

// Authenticated routes (auth enforced in handlers via verifyAuth)
app.post("/analyze-food", analyzeFoodImage);
app.post("/quick-scan", quickScan);
app.post("/backup", createBackup);
app.post("/restore", restoreBackup);
app.get("/backup-status", getBackupStatus);
app.get("/credits", getCreditsHandler);
app.get("/user/me", getUserProfile);

// 404 handler
app.use((_req: Request, res: Response) => {
  res.status(404).json({
    success: false,
    error: "Endpoint not found",
    code: "NOT_FOUND",
  });
});

export { app };
</file>

<file path="src/index.ts">
import { onRequest } from "firebase-functions/v2/https";
import { onSchedule } from "firebase-functions/v2/scheduler";
import { setGlobalOptions } from "firebase-functions/v2";
import { initializeApp, getApps } from "firebase-admin/app";
import { createNudgeHandler } from "./handlers/sendDailyNudge";
import { app } from "./api";
import { FUNCTION_CONFIG } from "./config/constants";

// Initialize Firebase Admin SDK (only if not already initialized)
if (getApps().length === 0) {
  initializeApp();
}

// Set global options for all functions
setGlobalOptions({
  region: FUNCTION_CONFIG.REGION,
  timeoutSeconds: FUNCTION_CONFIG.TIMEOUT_SECONDS,
});

/**
 * Consolidated API Endpoint
 *
 * Single Express app serving all HTTP routes:
 * - POST /register-device  (public)
 * - POST /analyze-food     (auth)
 * - POST /quick-scan       (auth)
 * - POST /backup           (auth)
 * - POST /restore          (auth)
 * - GET  /backup-status    (auth)
 * - GET  /credits          (auth)
 * - GET  /user/me          (auth)
 * - GET  /health           (public)
 *
 * invoker: 'public' is safe because all protected routes
 * enforce Firebase Auth via verifyAuth middleware.
 */
export const api = onRequest(
  {
    memory: FUNCTION_CONFIG.ANALYSIS_MEMORY, // 512MiB for vision workload
    timeoutSeconds: 60,
    invoker: "public",
  },
  app,
);

// =============================================================================
// Scheduled Push Notifications (IST times)
// =============================================================================

const SCHEDULE_CONFIG = {
  timeZone: "Asia/Kolkata",
  memory: FUNCTION_CONFIG.MEMORY,
} as const;

/**
 * Weight Reminder - 7:30 AM IST
 * Opens: platewise://entry
 */
export const weightReminder = onSchedule(
  { schedule: "30 7 * * *", ...SCHEDULE_CONFIG },
  createNudgeHandler("WEIGHT_REMINDER"),
);

/**
 * Breakfast Reminder - 8:30 AM IST
 * Opens: platewise://food/capture
 */
export const breakfastReminder = onSchedule(
  { schedule: "30 8 * * *", ...SCHEDULE_CONFIG },
  createNudgeHandler("BREAKFAST"),
);

/**
 * Lunch Reminder - 1:00 PM IST
 * Opens: platewise://food/capture
 */
export const lunchReminder = onSchedule(
  { schedule: "0 13 * * *", ...SCHEDULE_CONFIG },
  createNudgeHandler("LUNCH"),
);

/**
 * Snacks Reminder - 5:00 PM IST
 * Opens: platewise://food/capture
 */
export const snacksReminder = onSchedule(
  { schedule: "0 17 * * *", ...SCHEDULE_CONFIG },
  createNudgeHandler("SNACKS"),
);

/**
 * Dinner Reminder - 8:30 PM IST
 * Opens: platewise://food/capture
 */
export const dinnerReminder = onSchedule(
  { schedule: "30 20 * * *", ...SCHEDULE_CONFIG },
  createNudgeHandler("DINNER"),
);

/**
 * Evening Check-in - 9:30 PM IST
 * Opens: platewise://dashboard
 */
export const eveningCheckin = onSchedule(
  { schedule: "30 21 * * *", ...SCHEDULE_CONFIG },
  createNudgeHandler("EVENING_CHECKIN"),
);
</file>

<file path=".eslintrc.js">
module.exports = {
    root: true,
    env: {
        es2022: true,
        node: true,
    },
    extends: [
        "eslint:recommended",
        "plugin:import/errors",
        "plugin:import/warnings",
        "plugin:import/typescript",
        "google",
        "plugin:@typescript-eslint/recommended",
    ],
    parser: "@typescript-eslint/parser",
    parserOptions: {
        project: ["tsconfig.json"],
        sourceType: "module",
    },
    ignorePatterns: [
        "/lib/**/*",
        "/node_modules/**/*",
    ],
    plugins: [
        "@typescript-eslint",
        "import",
    ],
    rules: {
        "quotes": ["error", "double"],
        "import/no-unresolved": 0,
        "indent": ["error", 2],
        "max-len": ["error", { "code": 120 }],
        "object-curly-spacing": ["error", "always"],
        "require-jsdoc": 0,
        "valid-jsdoc": 0,
    },
};
</file>

<file path="package.json">
{
  "name": "weigh-backend-functions",
  "version": "1.0.0",
  "description": "Firebase Cloud Functions for weight-tracking mobile app",
  "main": "lib/index.js",
  "scripts": {
    "build": "tsc",
    "build:watch": "tsc --watch",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log",
    "lint": "eslint --ext .ts src/",
    "lint:fix": "eslint --ext .ts src/ --fix"
  },
  "engines": {
    "node": "20"
  },
  "dependencies": {
    "busboy": "^1.6.0",
    "cors": "^2.8.5",
    "firebase-admin": "^12.7.0",
    "firebase-functions": "^6.1.2",
    "openai": "^4.77.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/busboy": "^1.5.4",
    "@types/cors": "^2.8.19",
    "@typescript-eslint/eslint-plugin": "^8.18.1",
    "@typescript-eslint/parser": "^8.18.1",
    "eslint": "^8.57.1",
    "eslint-config-google": "^0.14.0",
    "eslint-plugin-import": "^2.31.0",
    "typescript": "^5.7.2"
  },
  "private": true
}
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "module": "commonjs",
        "noImplicitReturns": true,
        "noUnusedLocals": true,
        "outDir": "lib",
        "sourceMap": true,
        "strict": true,
        "target": "ES2022",
        "skipLibCheck": true,
        "esModuleInterop": true,
        "resolveJsonModule": true,
        "moduleResolution": "node",
        "declaration": true,
        "declarationMap": true
    },
    "compileOnSave": true,
    "include": [
        "src"
    ]
}
</file>

</files>
